This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitattributes
.vs/MyECSC_Prototype/v17/DocumentLayout.backup.json
.vs/MyECSC_Prototype/v17/DocumentLayout.json
ComponentArray.h
ComponentManager.c
ComponentManager.h
components.h
ComponentTypes.h
coordinator.c
coordinator.h
entity_manager.c
entity_manager.h
gravity_component.h
main.c
MyECSC_Prototype.sln
MyECSC_Prototype.vcxproj
MyECSC_Prototype.vcxproj.filters
MyECSC_Prototype.vcxproj.user
MyECSC_Prototype/x64/Debug/MyECSC_Prototype.exe.recipe
MyECSC_Prototype/x64/Debug/MyECSC_Prototype.tlog/Cl.items.tlog
MyECSC_Prototype/x64/Debug/MyECSC_Prototype.tlog/link.secondary.1.tlog
MyECSC_Prototype/x64/Debug/MyECSC_Prototype.tlog/MyECSC_Prototype.lastbuildstate
physics_component.h
physics_system.c
physics_system.h
render3d_system.c
render3d_system.h
rigid_body_component.h
system_manager.h
System.h
TransformComponent.h

================================================================
Files
================================================================

================
File: .gitattributes
================
# Auto detect text files and perform LF normalization
* text=auto

================
File: .vs/MyECSC_Prototype/v17/DocumentLayout.backup.json
================
{
  "Version": 1,
  "WorkspaceRootPath": "D:\\EntityComponent\\MyECSC_Prototype\\",
  "Documents": [
    {
      "AbsoluteMoniker": "D:0:0:{F677635E-4EC2-4FA0-94C8-B2F58CFFB8DA}|MyECSC_Prototype.vcxproj|D:\\EntityComponent\\MyECSC_Prototype\\main.c||{D0E1A5C6-B359-4E41-9B60-3365922C2A22}",
      "RelativeMoniker": "D:0:0:{F677635E-4EC2-4FA0-94C8-B2F58CFFB8DA}|MyECSC_Prototype.vcxproj|solutionrelative:main.c||{D0E1A5C6-B359-4E41-9B60-3365922C2A22}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{F677635E-4EC2-4FA0-94C8-B2F58CFFB8DA}|MyECSC_Prototype.vcxproj|D:\\EntityComponent\\MyECSC_Prototype\\render3d_system.c||{D0E1A5C6-B359-4E41-9B60-3365922C2A22}",
      "RelativeMoniker": "D:0:0:{F677635E-4EC2-4FA0-94C8-B2F58CFFB8DA}|MyECSC_Prototype.vcxproj|solutionrelative:render3d_system.c||{D0E1A5C6-B359-4E41-9B60-3365922C2A22}"
    }
  ],
  "DocumentGroupContainers": [
    {
      "Orientation": 0,
      "VerticalTabListWidth": 256,
      "DocumentGroups": [
        {
          "DockedWidth": 200,
          "SelectedChildIndex": 1,
          "Children": [
            {
              "$type": "Document",
              "DocumentIndex": 1,
              "Title": "render3d_system.c",
              "DocumentMoniker": "D:\\EntityComponent\\MyECSC_Prototype\\render3d_system.c",
              "RelativeDocumentMoniker": "render3d_system.c",
              "ToolTip": "D:\\EntityComponent\\MyECSC_Prototype\\render3d_system.c",
              "RelativeToolTip": "render3d_system.c",
              "ViewState": "AgIAAF0AAAAAAAAAAAAAAGYAAABTAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000423|",
              "WhenOpened": "2025-03-01T07:00:20.433Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 0,
              "Title": "main.c",
              "DocumentMoniker": "D:\\EntityComponent\\MyECSC_Prototype\\main.c",
              "RelativeDocumentMoniker": "main.c",
              "ToolTip": "D:\\EntityComponent\\MyECSC_Prototype\\main.c",
              "RelativeToolTip": "main.c",
              "ViewState": "AgIAADcAAAAAAAAAAAAowEUAAAAlAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000423|",
              "WhenOpened": "2025-02-27T09:09:41.632Z",
              "EditorCaption": ""
            }
          ]
        }
      ]
    }
  ]
}

================
File: .vs/MyECSC_Prototype/v17/DocumentLayout.json
================
{
  "Version": 1,
  "WorkspaceRootPath": "D:\\EntityComponent\\MyECSC_Prototype\\",
  "Documents": [
    {
      "AbsoluteMoniker": "D:0:0:{F677635E-4EC2-4FA0-94C8-B2F58CFFB8DA}|MyECSC_Prototype.vcxproj|D:\\EntityComponent\\MyECSC_Prototype\\main.c||{D0E1A5C6-B359-4E41-9B60-3365922C2A22}",
      "RelativeMoniker": "D:0:0:{F677635E-4EC2-4FA0-94C8-B2F58CFFB8DA}|MyECSC_Prototype.vcxproj|solutionrelative:main.c||{D0E1A5C6-B359-4E41-9B60-3365922C2A22}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{F677635E-4EC2-4FA0-94C8-B2F58CFFB8DA}|MyECSC_Prototype.vcxproj|D:\\EntityComponent\\MyECSC_Prototype\\render3d_system.c||{D0E1A5C6-B359-4E41-9B60-3365922C2A22}",
      "RelativeMoniker": "D:0:0:{F677635E-4EC2-4FA0-94C8-B2F58CFFB8DA}|MyECSC_Prototype.vcxproj|solutionrelative:render3d_system.c||{D0E1A5C6-B359-4E41-9B60-3365922C2A22}"
    }
  ],
  "DocumentGroupContainers": [
    {
      "Orientation": 0,
      "VerticalTabListWidth": 256,
      "DocumentGroups": [
        {
          "DockedWidth": 200,
          "SelectedChildIndex": 1,
          "Children": [
            {
              "$type": "Document",
              "DocumentIndex": 1,
              "Title": "render3d_system.c",
              "DocumentMoniker": "D:\\EntityComponent\\MyECSC_Prototype\\render3d_system.c",
              "RelativeDocumentMoniker": "render3d_system.c",
              "ToolTip": "D:\\EntityComponent\\MyECSC_Prototype\\render3d_system.c",
              "RelativeToolTip": "render3d_system.c",
              "ViewState": "AgIAAF0AAAAAAAAAAAAAAGYAAABTAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000423|",
              "WhenOpened": "2025-03-01T07:00:20.433Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 0,
              "Title": "main.c",
              "DocumentMoniker": "D:\\EntityComponent\\MyECSC_Prototype\\main.c",
              "RelativeDocumentMoniker": "main.c",
              "ToolTip": "D:\\EntityComponent\\MyECSC_Prototype\\main.c",
              "RelativeToolTip": "main.c",
              "ViewState": "AgIAADcAAAAAAAAAAAAowEQAAAAAAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000423|",
              "WhenOpened": "2025-02-27T09:09:41.632Z",
              "EditorCaption": ""
            }
          ]
        }
      ]
    }
  ]
}

================
File: ComponentArray.h
================
#pragma once

#ifndef COMPONENT_ARRAY_H
#define COMPONENT_ARRAY_H

#include <stdint.h>
#include <assert.h>
#include <stdlib.h>

#define MAX_ENTITIES 10000

// Base "interface" for component arrays.
typedef struct IComponentArray {
    void (*EntityDestroyed)(struct IComponentArray* self, uint32_t entity);
} IComponentArray;

// Macro to define a component array for any component type.
#define DEFINE_COMPONENT_ARRAY(ComponentType)                                                   \
    typedef struct {                                                                            \
        IComponentArray base;              /* Base interface */                                 \
        ComponentType components[MAX_ENTITIES]; /* Dense array of components */                   \
        int entityToIndexMap[MAX_ENTITIES];  /* Maps an entity to its index (-1 if absent) */      \
        uint32_t indexToEntityMap[MAX_ENTITIES]; /* Reverse mapping: index to entity */            \
        size_t size;                       /* Number of valid components */                     \
    } ComponentType##ComponentArray;                                                            \
                                                                                                \
    /* Forward declaration of the EntityDestroyed function */                                   \
    static inline void ComponentType##ComponentArray_EntityDestroyed(IComponentArray* base, uint32_t entity); \
                                                                                                \
    /* Initialization function for a component array */                                         \
    static inline void ComponentType##ComponentArray_Init(ComponentType##ComponentArray* arr) {   \
        arr->base.EntityDestroyed = (void (*)(IComponentArray*, uint32_t))                       \
            ComponentType##ComponentArray_EntityDestroyed;                                      \
        arr->size = 0;                                                                          \
        for (int i = 0; i < MAX_ENTITIES; i++) {                                                \
            arr->entityToIndexMap[i] = -1;                                                      \
        }                                                                                       \
    }                                                                                           \
                                                                                                \
    /* Insert a component into the array */                                                     \
    static inline void ComponentType##ComponentArray_Insert(ComponentType##ComponentArray* arr,    \
                                                             uint32_t entity,                 \
                                                             ComponentType component) {       \
        assert(arr->entityToIndexMap[entity] == -1 && "Component already exists for entity.");   \
        size_t newIndex = arr->size;                                                            \
        arr->entityToIndexMap[entity] = (int)newIndex; /* cast to int to avoid warning */        \
        arr->indexToEntityMap[newIndex] = entity;                                               \
        arr->components[newIndex] = component;                                                  \
        arr->size++;                                                                            \
    }                                                                                           \
                                                                                                \
    /* Remove a component from the array */                                                     \
    static inline void ComponentType##ComponentArray_RemoveData(ComponentType##ComponentArray* arr, \
                                                                  uint32_t entity) {             \
        assert(arr->entityToIndexMap[entity] != -1 && "Component does not exist for entity.");   \
        int indexOfRemovedEntity = arr->entityToIndexMap[entity];                               \
        size_t indexOfLastElement = arr->size - 1;                                                \
        /* Move the last component into the place of the removed component. */                  \
        arr->components[indexOfRemovedEntity] = arr->components[indexOfLastElement];              \
        /* Update the mapping for the entity that moved. */                                     \
        uint32_t entityOfLastElement = arr->indexToEntityMap[indexOfLastElement];                 \
        arr->entityToIndexMap[entityOfLastElement] = indexOfRemovedEntity;                        \
        arr->indexToEntityMap[indexOfRemovedEntity] = entityOfLastElement;                        \
        /* Mark the removed entity as having no component. */                                   \
        arr->entityToIndexMap[entity] = -1;                                                       \
        arr->size--;                                                                            \
    }                                                                                           \
                                                                                                \
    /* Retrieve a pointer to a component from the array */                                      \
    static inline ComponentType* ComponentType##ComponentArray_GetData(ComponentType##ComponentArray* arr, \
                                                                         uint32_t entity) {          \
        assert(arr->entityToIndexMap[entity] != -1 && "Component does not exist for entity.");   \
        int index = arr->entityToIndexMap[entity];                                               \
        return &arr->components[index];                                                          \
    }                                                                                           \
                                                                                                \
    /* Callback function for when an entity is destroyed */                                     \
    static inline void ComponentType##ComponentArray_EntityDestroyed(IComponentArray* base,      \
                                                                      uint32_t entity) {         \
        ComponentType##ComponentArray* arr = (ComponentType##ComponentArray*)base;              \
        if (arr->entityToIndexMap[entity] != -1) {                                                \
            ComponentType##ComponentArray_RemoveData(arr, entity);                              \
        }                                                                                       \
    }

#endif // COMPONENT_ARRAY_H

================
File: ComponentManager.c
================
//ComponentManager.c
#include "ComponentManager.h"
#include "ComponentArray.h"
#include "Components.h" 
#include "TransformComponent.h" 

#include <assert.h>

// Register a component array for a given type.
void ComponentManager_RegisterComponent(ComponentManager* mgr, ComponentType type, IComponentArray* array)
{
	assert(type < MAX_COMPONENT_TYPES && "Component type out of range.");
	mgr->componentArrays[type] = array;
}

// Notify all component arrays that an entity has been destroyed.
void ComponentManager_EntityDestroyed(ComponentManager* mgr, uint32_t entity)
{
	for (int i = 0; i < MAX_COMPONENT_TYPES; i++)
	{
		if (mgr->componentArrays[i]) 
			{
			// Call the EntityDestroyed function pointer on each registered component array
			mgr->componentArrays[i]->EntityDestroyed(mgr->componentArrays[i], entity);
			}
		{

		}
	}
}

================
File: ComponentManager.h
================
#pragma once

#ifndef COMPONENT_MANAGER_H
#define COMPONENT_MANAGER_H

#include <stdint.h>
#include "ComponentArray.h"      // Contains the base IComponentArray struct.
#include "ComponentTypes.h"      // Contains the ComponentType enum.
#include "Components.h"          // Now includes definitions for Entity and Transform.

// Define the maximum number of entities
#define MAX_COMPONENT_TYPES 32

// The ComponentManager is a collection of component arrays.
typedef struct ComponentManager {
	IComponentArray* componentArrays[MAX_COMPONENT_TYPES];
} ComponentManager;

// Register a component array for a given type.
void ComponentManager_RegisterComponent(ComponentManager* mgr, ComponentType type, IComponentArray* componentArray);

// Notify all component arrays that an entity has been destroyed.
void ComponentManager_EntityDestroyed(ComponentManager* mgr, uint32_t entity);


#endif

================
File: components.h
================
#pragma once
// Components.h
#ifndef COMPONENTS_H
#define COMPONENTS_H

#include <stdint.h>

// Define the Entity type.
typedef uint32_t Entity;

// Define a 3D vector.
typedef struct {
    float x;
    float y;
    float z;
} Vec3;

// Define a quaternion.
typedef struct {
    float x;
    float y;
    float z;
    float w;
} Quat;

// Define the Transform component.
typedef struct {
    Vec3 position;
    Quat rotation;
    Vec3 scale;
} Transform;

#endif // COMPONENTS_H

================
File: ComponentTypes.h
================
#pragma once

#ifndef COMPONENT_TYPES_H
#define COMPONENT_TYPES_H

typedef enum {
    COMPONENT_TRANSFORM = 0,
    COMPONENT_RIGID_BODY,
    COMPONENT_GRAVITY,
    COMPONENT_COUNT,
} ComponentType;

#endif // COMPONENT_TYPES_H

================
File: coordinator.c
================
#include "coordinator.h"
#include <assert.h>

// Initialize the Coordinator with pointers to the managers.
void Coordinator_Init(Coordinator* coordinator,
    EntityManager* entityManager,
    ComponentManager* componentManager,
    SystemManager* systemManager)
{
    coordinator->entityManager = entityManager;
    coordinator->componentManager = componentManager;
    coordinator->systemManager = systemManager;
}

// Create a new entity using the Entity Manager.
Entity Coordinator_CreateEntity(Coordinator* coordinator) {
    return EntityManager_CreateEntity(coordinator->entityManager);
}

// Destroy an entity and notify all managers.
void Coordinator_DestroyEntity(Coordinator* coordinator, Entity entity) {
    EntityManager_DestroyEntity(coordinator->entityManager, entity);
    ComponentManager_EntityDestroyed(coordinator->componentManager, entity);
    SystemManager_EntityDestroyed(coordinator->systemManager, entity);
}

// --- Transform Component Functions ---

// Add a Transform component to an entity.
void Coordinator_AddTransform(Coordinator* coordinator, Entity entity, Transform component) {
    IComponentArray* base = coordinator->componentManager->componentArrays[COMPONENT_TRANSFORM];
    assert(base && "Transform component array not registered.");
    TransformComponentArray* transformArray = (TransformComponentArray*)base;
    TransformComponentArray_Insert(transformArray, entity, component);

    // Update the entity's signature.
    Signature signature = EntityManager_GetSignature(coordinator->entityManager, entity);
    signature |= (1 << COMPONENT_TRANSFORM);
    EntityManager_SetSignature(coordinator->entityManager, entity, signature);

    // Notify systems about the signature change.
    SystemManager_EntitySignatureChanged(coordinator->systemManager, entity, signature);
}

// Retrieve a pointer to the Transform component of an entity.
Transform* Coordinator_GetTransform(Coordinator* coordinator, Entity entity) {
    IComponentArray* base = coordinator->componentManager->componentArrays[COMPONENT_TRANSFORM];
    assert(base && "Transform component array not registered.");
    TransformComponentArray* transformArray = (TransformComponentArray*)base;
    return TransformComponentArray_GetData(transformArray, entity);
}


// --- Gravity Component Functions ---

// Add a Gravity component to an entity.
void Coordinator_AddGravity(Coordinator* coordinator, Entity entity, Gravity component) {
    IComponentArray* base = coordinator->componentManager->componentArrays[COMPONENT_GRAVITY];
    assert(base && "Gravity component array not registered.");
    GravityComponentArray* gravityArray = (GravityComponentArray*)base;
    GravityComponentArray_Insert(gravityArray, entity, component);

    // Update the entity's signature.
    Signature signature = EntityManager_GetSignature(coordinator->entityManager, entity);
    signature |= (1 << COMPONENT_GRAVITY);
    EntityManager_SetSignature(coordinator->entityManager, entity, signature);

    // Notify systems about the signature change.
    SystemManager_EntitySignatureChanged(coordinator->systemManager, entity, signature);
}

// Retrieve a pointer to the Gravity component of an entity.
Gravity* Coordinator_GetGravity(Coordinator* coordinator, Entity entity) {
    IComponentArray* base = coordinator->componentManager->componentArrays[COMPONENT_GRAVITY];
    assert(base && "Gravity component array not registered.");
    GravityComponentArray* gravityArray = (GravityComponentArray*)base;
    return GravityComponentArray_GetData(gravityArray, entity);
}

// --- RigidBody Component Functions ---

// Add a RigidBody component to an entity.
void Coordinator_AddRigidBody(Coordinator* coordinator, Entity entity, RigidBody component) {
    IComponentArray* base = coordinator->componentManager->componentArrays[COMPONENT_RIGID_BODY];
    assert(base && "RigidBody component array not registered.");
    RigidBodyComponentArray* rbArray = (RigidBodyComponentArray*)base;
    RigidBodyComponentArray_Insert(rbArray, entity, component);

    // Update the entity's signature.
    Signature signature = EntityManager_GetSignature(coordinator->entityManager, entity);
    signature |= (1 << COMPONENT_RIGID_BODY);
    EntityManager_SetSignature(coordinator->entityManager, entity, signature);

    // Notify systems about the signature change.
    SystemManager_EntitySignatureChanged(coordinator->systemManager, entity, signature);
}

// Retrieve a pointer to the RigidBody component of an entity.
RigidBody* Coordinator_GetRigidBody(Coordinator* coordinator, Entity entity) {
    IComponentArray* base = coordinator->componentManager->componentArrays[COMPONENT_RIGID_BODY];
    assert(base && "RigidBody component array not registered.");
    RigidBodyComponentArray* rbArray = (RigidBodyComponentArray*)base;
    return RigidBodyComponentArray_GetData(rbArray, entity);
}

================
File: coordinator.h
================
#ifndef COORDINATOR_H
#define COORDINATOR_H

#include "entity_manager.h"
#include "ComponentManager.h"
#include "system_manager.h"
#include "ComponentTypes.h"
#include "Components.h"
#include "TransformComponent.h"
#include "rigid_body_component.h"
#include "gravity_component.h"
#include "physics_component.h"

// The Coordinator bundles all the managers.
typedef struct {
    EntityManager* entityManager;
    ComponentManager* componentManager;
    SystemManager* systemManager;
} Coordinator;

// Initialization.
void Coordinator_Init(Coordinator* coordinator,
    EntityManager* entityManager,
    ComponentManager* componentManager,
    SystemManager* systemManager);

// Entity management.
Entity Coordinator_CreateEntity(Coordinator* coordinator);
void Coordinator_DestroyEntity(Coordinator* coordinator, Entity entity);

// Transform component management.
void Coordinator_AddTransform(Coordinator* coordinator, Entity entity, Transform component);
Transform* Coordinator_GetTransform(Coordinator* coordinator, Entity entity);

// Gravity component management.
void Coordinator_AddGravity(Coordinator* coordinator, Entity entity, Gravity component);
Gravity* Coordinator_GetGravity(Coordinator* coordinator, Entity entity);

// RigidBody component management.
void Coordinator_AddRigidBody(Coordinator* coordinator, Entity entity, RigidBody component);
RigidBody* Coordinator_GetRigidBody(Coordinator* coordinator, Entity entity);


#endif // COORDINATOR_H

================
File: entity_manager.c
================
#include "entity_manager.h"

void EntityManager_Init(EntityManager *manager) {
    for (Entity i = 0; i < MAX_ENTITIES; i++) {
        manager->availableEntities[i] = i;
        manager->signatures[i] = 0; // No components initially.
    }
    manager->head = 0;
    manager->tail = 0; // When the queue is full, head == tail.
    manager->count = MAX_ENTITIES;
    manager->LivingEntityCount = 0;
}

Entity EntityManager_CreateEntity(EntityManager *manager) {
	assert(manager->LivingEntityCount < MAX_ENTITIES && "Too many entities in existence.");
	assert(manager->count > 0 && "Ran out of available entities.");

	// Take an ID from the front of the queue.
	Entity id = manager->availableEntities[manager->head];
	manager->head = (manager->head + 1) % MAX_ENTITIES;
	manager->count--;
	manager->LivingEntityCount++;
	return id;
}

void EntityManager_DestroyEntity(EntityManager *manager, Entity entity) {
	assert(entity < MAX_ENTITIES && "Entity out of range.");
	// Invalidate the destroyed entity's signature.
	manager->signatures[entity] = 0;
	// Put the destroyed ID at the back of the queue.
	manager->availableEntities[manager->tail] = entity;
	manager->tail = (manager->tail + 1) % MAX_ENTITIES;
	manager->count++;
	manager->LivingEntityCount--;
}

void EntityManager_SetSignature(EntityManager *manager, Entity entity, Signature signature) {
	assert(entity < MAX_ENTITIES && "Entity out of range.");
	manager->signatures[entity] = signature;
}

Signature EntityManager_GetSignature(EntityManager *manager, Entity entity) {
	assert(entity < MAX_ENTITIES && "Entity out of range.");
	return manager->signatures[entity];
}

================
File: entity_manager.h
================
#pragma once
#ifndef ENTITY_MANAGER_H
#define ENTITY_MANAGER_H

#include <stdint.h>
#include <stdio.h>
#include <assert.h>

// Define the maximum number of entities
#define MAX_ENTITIES 10000

// Define an entity as an unsigned 32-bit integer

typedef uint32_t Entity;

// Define a signature as an unsigned 32-bit integer

typedef uint32_t Signature;

// The EntityManager holds available IDs, an array of signatures (one for each entity), and a counts
typedef struct
{
	Entity availableEntities[MAX_ENTITIES];
	int head;
	int tail;
	int count;
	Signature signatures[MAX_ENTITIES]; // each entity has a signature
	uint32_t LivingEntityCount;
} EntityManager;


// Initialize the EntityManager
void EntityManager_Init(EntityManager *manager);

// Create a new entity by returning the next available ID
Entity EntityManager_CreateEntity(EntityManager *manager);

// Destroy an entity by adding its ID to the available IDs
void EntityManager_DestroyEntity(EntityManager *manager, Entity entity);

// Set the signature of an entity
void EntityManager_SetSignature(EntityManager *manager, Entity entity, Signature signature);

// Get the signature of an entity
Signature EntityManager_GetSignature(EntityManager *manager, Entity entity);


#endif // !ENTITY_MANAGER_H

================
File: gravity_component.h
================
#ifndef GRAVITY_COMPONENT_H
#define GRAVITY_COMPONENT_H

#include "components.h"
#include "ComponentArray.h"

typedef struct {
    Vec3 force;
} Gravity;

DEFINE_COMPONENT_ARRAY(Gravity);

#endif // GRAVITY_COMPONENT_H

================
File: main.c
================
#include <SDL3/SDL.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "coordinator.h"
#include "entity_manager.h"
#include "ComponentManager.h"
#include "system_manager.h"
#include "ComponentTypes.h"
#include "TransformComponent.h"
#include "gravity_component.h"
#include "rigid_body_component.h"
#include "physics_system.h"
#include "Components.h"
#include "render3d_system.h"

static SDL_Color entityColors[MAX_ENTITIES];

int main(void) {
    // --- Initialize ECS Managers ---
    EntityManager* entityManager = malloc(sizeof(EntityManager));
    if (!entityManager) return 1;
    EntityManager_Init(entityManager);

    ComponentManager* componentManager = malloc(sizeof(ComponentManager));
    if (!componentManager) return 1;
    for (int i = 0; i < MAX_COMPONENT_TYPES; i++) {
        componentManager->componentArrays[i] = NULL;
    }

    SystemManager* systemManager = malloc(sizeof(SystemManager));
    if (!systemManager) return 1;
    systemManager->count = 0;

    // Register component arrays.
    TransformComponentArray* transformArray = malloc(sizeof(TransformComponentArray));
    if (!transformArray) return 1;
    TransformComponentArray_Init(transformArray);
    ComponentManager_RegisterComponent(componentManager, COMPONENT_TRANSFORM, (IComponentArray*)transformArray);

    GravityComponentArray* gravityArray = malloc(sizeof(GravityComponentArray));
    if (!gravityArray) return 1;
    GravityComponentArray_Init(gravityArray);
    ComponentManager_RegisterComponent(componentManager, COMPONENT_GRAVITY, (IComponentArray*)gravityArray);

    RigidBodyComponentArray* rigidBodyArray = malloc(sizeof(RigidBodyComponentArray));
    if (!rigidBodyArray) return 1;
    RigidBodyComponentArray_Init(rigidBodyArray);
    ComponentManager_RegisterComponent(componentManager, COMPONENT_RIGID_BODY, (IComponentArray*)rigidBodyArray);

    // --- Register Systems ---
    PhysicsSystem* physicsSystem = malloc(sizeof(PhysicsSystem));
    if (!physicsSystem) return 1;
    PhysicsSystem_Init(physicsSystem, componentManager);
    SystemManager_AddSystem(systemManager, (ECS_System*)physicsSystem);

    // Initialize the Render3DSystem.
    Render3DSystem render3dSystem;
    Render3DSystem_Init(&render3dSystem, componentManager);
    SystemManager_AddSystem(systemManager, (ECS_System*)&render3dSystem);

    // Initialize the coordinator.
    Coordinator coordinator;
    Coordinator_Init(&coordinator, entityManager, componentManager, systemManager);

    // Set up randomization.
    srand((unsigned)time(NULL));
    int numEntities = 100;

    // Create 100 entities with randomized Gravity, RigidBody, and Transform.
    for (int i = 0; i < numEntities; i++) {
        Entity entity = Coordinator_CreateEntity(&coordinator);

        float randPosX = ((float)rand() / RAND_MAX) * 10.0f - 5.0f;  // X in [-5,5]
        float randPosY = ((float)rand() / RAND_MAX) * 10.0f - 5.0f;  // Y in [-5,5]
        float randPosZ = 20.0f;                                      // Place cubes in front of camera
        float randRot = ((float)rand() / RAND_MAX) * 0.5f;           // Smaller rotation angle
        float scale = 1.0f;                                        // Unit-sized cube
        float gravityValue = 9.8f;                                   // Realistic gravity

        Gravity g = { { 0.0f, gravityValue, 0.0f } };
        RigidBody rb = { {0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f} };
        Transform t = { { randPosX, randPosY, randPosZ },
                        { randRot, randRot, randRot },
                        { scale, scale, scale } };

        // Assign random color
        entityColors[i].r = rand() % 256;  
        entityColors[i].g = rand() % 256;
        entityColors[i].b = rand() % 256;
        entityColors[i].a = 255;          

        Coordinator_AddGravity(&coordinator, entity, g);
        Coordinator_AddRigidBody(&coordinator, entity, rb);
        Coordinator_AddTransform(&coordinator, entity, t);
    }

    // ---- Initialize SDL3 ----
    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
        fprintf(stderr, "SDL_Init Error: %s\n", SDL_GetError());
        return 1;
    }

    // Create a window with a larger canvas (1280x720)
    SDL_Window* window = SDL_CreateWindow("Falling Blocks Demo", 1280, 720, 0);
    if (!window) {
        fprintf(stderr, "SDL_CreateWindow Error: %s\n", SDL_GetError());
        SDL_Quit();
        return 1;
    }


    SDL_Renderer* renderer = SDL_CreateRenderer(window, "opengl");
    if (!renderer) {
        fprintf(stderr, "SDL_CreateRenderer Error: %s\n", SDL_GetError());
        SDL_DestroyWindow(window);
        SDL_Quit();
        return 1;
    }

    // Main loop variables
    int quit = 0;
    SDL_Event event;
    float dt = 0.016f; // ~16 ms per frame (60 FPS)
    int iterations = 0;

    // ---- Main Loop: Update and Render ----
    while (!quit) {
        // Handle events (SDL3 renames SDL_QUIT to SDL_EVENT_QUIT)
        while (SDL_PollEvent(&event)) {
            if (event.type == SDL_EVENT_QUIT) {
                quit = 1;
            }
        }

        // Update simulation (apply physics)
        PhysicsSystem_Update(physicsSystem, dt);

        // Clear screen (black background)
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
        SDL_RenderClear(renderer);

        // Update and render 3D boxes.
        Render3DSystem_Update(&render3dSystem, dt, renderer, 1280, 720);

        SDL_RenderPresent(renderer);
        SDL_Delay(16);
        iterations++;
        if (iterations > 1000)
            quit = 1;
    }

    // Cleanup.
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();

    free(physicsSystem);
    free(rigidBodyArray);
    free(gravityArray);
    free(transformArray);
    free(systemManager);
    free(componentManager);
    free(entityManager);

    return 0;
}

================
File: MyECSC_Prototype.sln
================
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.13.35806.99
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MyECSC_Prototype", "MyECSC_Prototype.vcxproj", "{F677635E-4EC2-4FA0-94C8-B2F58CFFB8DA}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SDL3", "C:\Users\Alan\source\repos\SDL\VisualC\SDL\SDL.vcxproj", "{81CE8DAF-EBB2-4761-8E45-B71ABCCA8C68}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F677635E-4EC2-4FA0-94C8-B2F58CFFB8DA}.Debug|x64.ActiveCfg = Debug|x64
		{F677635E-4EC2-4FA0-94C8-B2F58CFFB8DA}.Debug|x64.Build.0 = Debug|x64
		{F677635E-4EC2-4FA0-94C8-B2F58CFFB8DA}.Debug|x86.ActiveCfg = Debug|Win32
		{F677635E-4EC2-4FA0-94C8-B2F58CFFB8DA}.Debug|x86.Build.0 = Debug|Win32
		{F677635E-4EC2-4FA0-94C8-B2F58CFFB8DA}.Release|x64.ActiveCfg = Release|x64
		{F677635E-4EC2-4FA0-94C8-B2F58CFFB8DA}.Release|x64.Build.0 = Release|x64
		{F677635E-4EC2-4FA0-94C8-B2F58CFFB8DA}.Release|x86.ActiveCfg = Release|Win32
		{F677635E-4EC2-4FA0-94C8-B2F58CFFB8DA}.Release|x86.Build.0 = Release|Win32
		{81CE8DAF-EBB2-4761-8E45-B71ABCCA8C68}.Debug|x64.ActiveCfg = Debug|x64
		{81CE8DAF-EBB2-4761-8E45-B71ABCCA8C68}.Debug|x64.Build.0 = Debug|x64
		{81CE8DAF-EBB2-4761-8E45-B71ABCCA8C68}.Debug|x86.ActiveCfg = Debug|Win32
		{81CE8DAF-EBB2-4761-8E45-B71ABCCA8C68}.Debug|x86.Build.0 = Debug|Win32
		{81CE8DAF-EBB2-4761-8E45-B71ABCCA8C68}.Release|x64.ActiveCfg = Release|x64
		{81CE8DAF-EBB2-4761-8E45-B71ABCCA8C68}.Release|x64.Build.0 = Release|x64
		{81CE8DAF-EBB2-4761-8E45-B71ABCCA8C68}.Release|x86.ActiveCfg = Release|Win32
		{81CE8DAF-EBB2-4761-8E45-B71ABCCA8C68}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {92FBAFE9-72C8-4CB3-9981-ABF05B35D22B}
	EndGlobalSection
EndGlobal

================
File: MyECSC_Prototype.vcxproj
================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{f677635e-4ec2-4fa0-94c8-b2f58cffb8da}</ProjectGuid>
    <RootNamespace>MyECSCPrototype</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <IncludePath>C:\Users\Alan\source\repos\SDL\VisualC\SDL;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <IncludePath>C:\Users\Alan\source\repos\SDL\VisualC\SDL;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <IncludePath>C:\Users\Alan\source\repos\SDL\VisualC\SDL;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <IncludePath>C:\Users\Alan\source\repos\SDL\VisualC\SDL;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>D:\SDL2\SDL3-3.2.4\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>D:\SDL2\SDL3-3.2.4\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>SDL2.lib;SDL2main.lib;
;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>D:\SDL2\SDL3-3.2.4\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>D:\SDL2\SDL3-3.2.4\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>SDL2.lib;SDL2main.lib;
;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>D:\SDL2\SDL3-3.2.4\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>D:\SDL2\SDL3-3.2.4\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>SDL3.lib;SDL3_test.lib;
;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>D:\SDL2\SDL3-3.2.4\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>D:\SDL2\SDL3-3.2.4\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>SDL2.lib;SDL2main.lib;
;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="ComponentManager.c" />
    <ClCompile Include="coordinator.c" />
    <ClCompile Include="entity_manager.c" />
    <ClCompile Include="main.c">
      <CompileAs Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">CompileAsC</CompileAs>
    </ClCompile>
    <ClCompile Include="physics_system.c" />
    <ClCompile Include="physics_system.h" />
    <ClCompile Include="render3d_system.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ComponentArray.h" />
    <ClInclude Include="ComponentManager.h" />
    <ClInclude Include="components.h" />
    <ClInclude Include="ComponentTypes.h" />
    <ClInclude Include="coordinator.h" />
    <ClInclude Include="entity_manager.h" />
    <ClInclude Include="gravity_component.h" />
    <ClInclude Include="physics_component.h" />
    <ClInclude Include="render3d_system.h" />
    <ClInclude Include="rigid_body_component.h" />
    <ClInclude Include="System.h" />
    <ClInclude Include="system_manager.h" />
    <ClInclude Include="TransformComponent.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

================
File: MyECSC_Prototype.vcxproj.filters
================
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Source Files\EntityManager">
      <UniqueIdentifier>{2c594161-3257-421c-ba2c-a00d85bff169}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\ComponentManager">
      <UniqueIdentifier>{9a4c6392-bfb5-48bc-a923-d3f888eee8b6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\System">
      <UniqueIdentifier>{5fab541b-7fbb-45dd-8313-e74f432b0e2c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Physics">
      <UniqueIdentifier>{98fa73de-90d8-4002-a4f6-75d19bbd7d26}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Macro">
      <UniqueIdentifier>{fa32c8a9-748a-4161-b6cc-d71713558aa2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Coordinator">
      <UniqueIdentifier>{9c65f4b4-583d-4637-8b80-7222e1f96b82}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Components">
      <UniqueIdentifier>{9ed59cfa-6ce1-46e2-815a-9daf955489b1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Render3D">
      <UniqueIdentifier>{08bb49ba-9164-441b-9e10-728c7bb78e3b}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="entity_manager.c">
      <Filter>Source Files\EntityManager</Filter>
    </ClCompile>
    <ClCompile Include="ComponentManager.c">
      <Filter>Source Files\ComponentManager</Filter>
    </ClCompile>
    <ClCompile Include="physics_system.h">
      <Filter>Source Files\Physics</Filter>
    </ClCompile>
    <ClCompile Include="physics_system.c">
      <Filter>Source Files\Physics</Filter>
    </ClCompile>
    <ClCompile Include="coordinator.c">
      <Filter>Source Files\Coordinator</Filter>
    </ClCompile>
    <ClCompile Include="render3d_system.c">
      <Filter>Source Files\Render3D</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="entity_manager.h">
      <Filter>Source Files\EntityManager</Filter>
    </ClInclude>
    <ClInclude Include="ComponentArray.h">
      <Filter>Source Files\Macro</Filter>
    </ClInclude>
    <ClInclude Include="ComponentTypes.h">
      <Filter>Source Files\ComponentManager</Filter>
    </ClInclude>
    <ClInclude Include="ComponentManager.h">
      <Filter>Source Files\ComponentManager</Filter>
    </ClInclude>
    <ClInclude Include="TransformComponent.h">
      <Filter>Source Files\ComponentManager</Filter>
    </ClInclude>
    <ClInclude Include="System.h">
      <Filter>Source Files\System</Filter>
    </ClInclude>
    <ClInclude Include="system_manager.h">
      <Filter>Source Files\System</Filter>
    </ClInclude>
    <ClInclude Include="physics_component.h">
      <Filter>Source Files\Physics</Filter>
    </ClInclude>
    <ClInclude Include="coordinator.h">
      <Filter>Source Files\Coordinator</Filter>
    </ClInclude>
    <ClInclude Include="gravity_component.h">
      <Filter>Source Files\Components</Filter>
    </ClInclude>
    <ClInclude Include="rigid_body_component.h">
      <Filter>Source Files\Components</Filter>
    </ClInclude>
    <ClInclude Include="render3d_system.h">
      <Filter>Source Files\Render3D</Filter>
    </ClInclude>
    <ClInclude Include="components.h">
      <Filter>Source Files\Components</Filter>
    </ClInclude>
  </ItemGroup>
</Project>

================
File: MyECSC_Prototype.vcxproj.user
================
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>

================
File: MyECSC_Prototype/x64/Debug/MyECSC_Prototype.exe.recipe
================
<?xml version="1.0" encoding="utf-8"?>
<Project>
  <ProjectOutputs>
    <ProjectOutput>
      <FullPath>D:\EntityComponent\MyECSC_Prototype\x64\Debug\MyECSC_Prototype.exe</FullPath>
    </ProjectOutput>
  </ProjectOutputs>
  <ContentFiles />
  <SatelliteDlls />
  <NonRecipeFileRefs />
</Project>

================
File: MyECSC_Prototype/x64/Debug/MyECSC_Prototype.tlog/Cl.items.tlog
================
D:\EntityComponent\MyECSC_Prototype\ComponentManager.c;D:\EntityComponent\MyECSC_Prototype\MyECSC_Prototype\x64\Debug\ComponentManager.obj
D:\EntityComponent\MyECSC_Prototype\coordinator.c;D:\EntityComponent\MyECSC_Prototype\MyECSC_Prototype\x64\Debug\coordinator.obj
D:\EntityComponent\MyECSC_Prototype\entity_manager.c;D:\EntityComponent\MyECSC_Prototype\MyECSC_Prototype\x64\Debug\entity_manager.obj
D:\EntityComponent\MyECSC_Prototype\main.c;D:\EntityComponent\MyECSC_Prototype\MyECSC_Prototype\x64\Debug\main.obj
D:\EntityComponent\MyECSC_Prototype\physics_system.c;D:\EntityComponent\MyECSC_Prototype\MyECSC_Prototype\x64\Debug\physics_system.obj
D:\EntityComponent\MyECSC_Prototype\physics_system.h;D:\EntityComponent\MyECSC_Prototype\MyECSC_Prototype\x64\Debug\physics_system.obj
D:\EntityComponent\MyECSC_Prototype\render3d_system.c;D:\EntityComponent\MyECSC_Prototype\MyECSC_Prototype\x64\Debug\render3d_system.obj

================
File: MyECSC_Prototype/x64/Debug/MyECSC_Prototype.tlog/link.secondary.1.tlog
================
^D:\ENTITYCOMPONENT\MYECSC_PROTOTYPE\MYECSC_PROTOTYPE\X64\DEBUG\COMPONENTMANAGER.OBJ|D:\ENTITYCOMPONENT\MYECSC_PROTOTYPE\MYECSC_PROTOTYPE\X64\DEBUG\COORDINATOR.OBJ|D:\ENTITYCOMPONENT\MYECSC_PROTOTYPE\MYECSC_PROTOTYPE\X64\DEBUG\ENTITY_MANAGER.OBJ|D:\ENTITYCOMPONENT\MYECSC_PROTOTYPE\MYECSC_PROTOTYPE\X64\DEBUG\MAIN.OBJ|D:\ENTITYCOMPONENT\MYECSC_PROTOTYPE\MYECSC_PROTOTYPE\X64\DEBUG\PHYSICS_SYSTEM.OBJ|D:\ENTITYCOMPONENT\MYECSC_PROTOTYPE\MYECSC_PROTOTYPE\X64\DEBUG\PHYSICS_SYSTEM.OBJ|D:\ENTITYCOMPONENT\MYECSC_PROTOTYPE\MYECSC_PROTOTYPE\X64\DEBUG\RENDER3D_SYSTEM.OBJ
D:\EntityComponent\MyECSC_Prototype\MyECSC_Prototype\x64\Debug\MyECSC_Prototype.ilk

================
File: MyECSC_Prototype/x64/Debug/MyECSC_Prototype.tlog/MyECSC_Prototype.lastbuildstate
================
PlatformToolSet=v143:VCToolArchitecture=Native64Bit:VCToolsVersion=14.38.33130:TargetPlatformVersion=10.0.22621.0:
Debug|x64|D:\EntityComponent\MyECSC_Prototype\|

================
File: physics_component.h
================
// physics_component.h

#ifndef PHYSICS_COMPONENT_H
#define PHYSICS_COMPONENT_H

#include "components.h" // for Vec3
#include "ComponentArray.h" 

// Define the physics component
typedef struct {
	Vec3 velocity;
	Vec3 force;
} Physics;

// Create a physics component array
DEFINE_COMPONENT_ARRAY(Physics);

#endif // !PHYSICS_COMPONENT_H

================
File: physics_system.c
================
#include "physics_system.h"
#include <assert.h>

void PhysicsSystem_Init(PhysicsSystem* psys, ComponentManager* cm) {
    psys->base.count = 0;
    psys->base.requiredSignature = (1 << COMPONENT_TRANSFORM) |
        (1 << COMPONENT_RIGID_BODY) |
        (1 << COMPONENT_GRAVITY);
    psys->componentManager = cm;
}

void PhysicsSystem_Update(PhysicsSystem* psys, float dt) {
    // Retrieve the component arrays from the ComponentManager.
    TransformComponentArray* transformArray = (TransformComponentArray*)psys->componentManager->componentArrays[COMPONENT_TRANSFORM];
    RigidBodyComponentArray* rigidBodyArray = (RigidBodyComponentArray*)psys->componentManager->componentArrays[COMPONENT_RIGID_BODY];
    GravityComponentArray* gravityArray = (GravityComponentArray*)psys->componentManager->componentArrays[COMPONENT_GRAVITY];

    for (int i = 0; i < psys->base.count; i++) {
        Entity entity = psys->base.entities[i];

        Transform* transform = TransformComponentArray_GetData(transformArray, entity);
        RigidBody* rigidBody = RigidBodyComponentArray_GetData(rigidBodyArray, entity);
        Gravity* gravity = GravityComponentArray_GetData(gravityArray, entity);

        // Update the position using the current velocity.
        transform->position.x += rigidBody->velocity.x * dt;
        transform->position.y += rigidBody->velocity.y * dt;
        transform->position.z += rigidBody->velocity.z * dt;

        // Update the velocity based on gravity.
        rigidBody->velocity.x += gravity->force.x * dt;
        rigidBody->velocity.y += gravity->force.y * dt;
        rigidBody->velocity.z += gravity->force.z * dt;
    }
}

================
File: physics_system.h
================
#ifndef PHYSICS_SYSTEM_H
#define PHYSICS_SYSTEM_H

#include "entity_manager.h"
#include "ComponentManager.h"
#include "ComponentTypes.h"
#include "TransformComponent.h"
#include "rigid_body_component.h"
#include "gravity_component.h"
#include "System.h"           

// Base System structure.
typedef struct {
    ECS_System base;  // Contains the entity list and the required signature.
    ComponentManager* componentManager;
} PhysicsSystem;

// Initializes the physics system by setting its required signature and storing the ComponentManager.
void PhysicsSystem_Init(PhysicsSystem* psys, ComponentManager* cm);

// Updates the physics system by applying simple physics (Euler integration) to all entities.
void PhysicsSystem_Update(PhysicsSystem* psys, float dt);

#endif // PHYSICS_SYSTEM_H

================
File: render3d_system.c
================
#include "render3d_system.h"
#include "TransformComponent.h"  // To access Transform definitions
#include "coordinator.h"
#include "components.h"

// --- 3D Math Helpers ---

static inline Vec3 vec3_add(Vec3 a, Vec3 b) {
    Vec3 result = { a.x + b.x, a.y + b.y, a.z + b.z };
    return result;
}

static inline Vec3 vec3_scale(Vec3 v, float s) {
    Vec3 result = { v.x * s, v.y * s, v.z * s };
    return result;
}

// For simplicity, rotate around the Z-axis (this demo can be extended later).
static inline Vec3 vec3_rotate_z(Vec3 v, float angle) {
    float cosA = cosf(angle);
    float sinA = sinf(angle);
    Vec3 result = { v.x * cosA - v.y * sinA, v.x * sinA + v.y * cosA, v.z };
    return result;
}

// --- Projection Helper ---
// Simple perspective projection: adjust fov and viewerDistance as needed.
static inline void projectPoint(const Vec3* point, float fov, float viewerDistance, float* outX, float* outY) {
    float factor = fov / (viewerDistance + point->z);
    *outX = point->x * factor;
    *outY = point->y * factor;
}

// --- Wireframe Cube Rendering ---
// This function defines a unit cube (from -0.5 to 0.5 in each axis),
// applies transformation, projects to 2D, and draws edges.
static void renderWireCube(SDL_Renderer* renderer, Vec3 center, float rotation, float scale,
    SDL_Color color, float fov, float viewerDistance, int screenWidth, int screenHeight)
{
    // Define the 8 vertices of a unit cube.
    Vec3 vertices[8] = {
        { -0.5f, -0.5f, -0.5f },
        {  0.5f, -0.5f, -0.5f },
        {  0.5f,  0.5f, -0.5f },
        { -0.5f,  0.5f, -0.5f },
        { -0.5f, -0.5f,  0.5f },
        {  0.5f, -0.5f,  0.5f },
        {  0.5f,  0.5f,  0.5f },
        { -0.5f,  0.5f,  0.5f }
    };

    Vec3 transformed[8];
    for (int i = 0; i < 8; i++) {
        // Scale
        Vec3 v = vec3_scale(vertices[i], scale);
        // Rotate around Z (for simplicity)
        v = vec3_rotate_z(v, rotation);
        // Translate to center
        transformed[i] = vec3_add(v, center);
    }

    // Project vertices to 2D.
    SDL_FPoint projected[8];
    for (int i = 0; i < 8; i++) {
        float projX, projY;
        projectPoint(&transformed[i], fov, viewerDistance, &projX, &projY);
        // Center the projection on screen.
        projected[i].x = projX + screenWidth / 2.0f;
        projected[i].y = -projY + screenHeight / 2.0f; // invert y for screen coords
    }

    // Define edges between vertices.
    int edges[12][2] = {
        {0,1}, {1,2}, {2,3}, {3,0}, // bottom face
        {4,5}, {5,6}, {6,7}, {7,4}, // top face
        {0,4}, {1,5}, {2,6}, {3,7}  // vertical edges
    };

    SDL_SetRenderDrawColor(renderer, color.r, color.g, color.b, color.a);
    for (int i = 0; i < 12; i++) {
        int a = edges[i][0], b = edges[i][1];
        SDL_RenderLine(renderer, projected[a].x, projected[a].y, projected[b].x, projected[b].y);
    }
}

// --- Render3DSystem Functions ---

void Render3DSystem_Init(Render3DSystem* r3dSys, ComponentManager* cm) {
    // For this demo, we require only the Transform component.
    r3dSys->base.count = 0;
    r3dSys->base.requiredSignature = (1 << COMPONENT_TRANSFORM);
    r3dSys->componentManager = cm;
}

void Render3DSystem_Update(Render3DSystem* r3dSys, float dt, SDL_Renderer* renderer, int screenWidth, int screenHeight) {

    // Projection settings - adjust these to change the 3D view.
    float fov = 100.0f;          // Field-of-view factor.
    float viewerDistance = 1.0f; // Distance from the viewer to the projection plane.
 

	// Get the Transform component array.
    TransformComponentArray* transformArray = (TransformComponentArray*)r3dSys->componentManager->componentArrays[COMPONENT_TRANSFORM];

    // Loop over entities managed by this system.
    for (int i = 0; i < r3dSys->base.count; i++) {
        Entity entity = r3dSys->base.entities[i];
        // Get the Transform component from our ECS.
        Transform* t = TransformComponentArray_GetData(transformArray, entity);
        if (t) {
            // Use the transform as the cube's parameters.
            // Center in 3D is taken directly from t->position.
            Vec3 center = { t->position.x, t->position.y, t->position.z };
            // Use the x scale as the cube's size; use rotation.x for simplicity.
            float scale = t->scale.x;
            float rotation = t->rotation.x;
            // For this demo, we'll use a fixed color (white) or you could add color data.
            SDL_Color color = { 255, 255, 255, 255 };

            // Render the cube.
            renderWireCube(renderer, center, rotation, scale, color, fov, viewerDistance, screenWidth, screenHeight);
        }
    }
}

================
File: render3d_system.h
================
#ifndef RENDER3D_SYSTEM_H
#define RENDER3D_SYSTEM_H

#include "System.h"
#include "entity_manager.h"
#include "ComponentManager.h"
#include "ComponentTypes.h"
#include "SDL3/SDL.h"
#include <math.h>

// Render3DSystem structure that holds a base ECS_System and a pointer to the ComponentManager.
typedef struct {
    ECS_System base;            // Contains the list of entities and required signature.
    ComponentManager* componentManager;
    // You could add more fields here for projection settings, etc.
} Render3DSystem;

// Initialize the Render3DSystem with the ComponentManager.
void Render3DSystem_Init(Render3DSystem* r3dSys, ComponentManager* cm);

// Update the Render3DSystem: for each entity, render a 3D wireframe cube.
// The renderer, dt, and screen parameters are passed in.
void Render3DSystem_Update(Render3DSystem* r3dSys, float dt, SDL_Renderer* renderer, int screenWidth, int screenHeight);

#endif // RENDER3D_SYSTEM_H

================
File: rigid_body_component.h
================
#ifndef RIGID_BODY_COMPONENT_H
#define RIGID_BODY_COMPONENT_H

#include "components.h"
#include "ComponentArray.h"

typedef struct {
    Vec3 velocity;
    Vec3 acceleration;
} RigidBody;

DEFINE_COMPONENT_ARRAY(RigidBody);

#endif // RIGID_BODY_COMPONENT_H

================
File: system_manager.h
================
#pragma once

// system_manager.h
#ifndef SYSTEM_MANAGER_H
#define SYSTEM_MANAGER_H

#include "System.h"
#include "entity_manager.h"
#include "ComponentTypes.h"
#include <assert.h>

#define MAX_SYSTEMS 32

typedef struct {
    ECS_System* systems[MAX_SYSTEMS]; // Fixed struct name
    int count;
} SystemManager;

// Register a system with the system manager
static inline void SystemManager_AddSystem(SystemManager* mgr, ECS_System* sys) {
    assert(mgr->count < MAX_SYSTEMS && "System Manager is full");
    mgr->systems[mgr->count++] = sys;
}

// Called when an entity is destroyed
static inline void SystemManager_EntityDestroyed(SystemManager* mgr, Entity entity) {
    for (int i = 0; i < mgr->count; i++) {
        ECS_System_RemoveEntity(mgr->systems[i], entity); // Fixed function call
    }
}

// Called when the signature of an entity changes
static inline void SystemManager_EntitySignatureChanged(SystemManager* mgr, Entity entity, Signature entitySignature) {
    for (int i = 0; i < mgr->count; i++) {
        ECS_System* sys = mgr->systems[i];

        // Check if entity has all the required components
        if ((entitySignature & sys->requiredSignature) == sys->requiredSignature) {
            ECS_System_AddEntity(sys, entity); // Fixed function call
        }
        else {
            ECS_System_RemoveEntity(sys, entity); // Fixed function call
        }
    }
}

#endif // !SYSTEM_MANAGER_H

================
File: System.h
================
// system.h
#ifndef SYSTEM_H
#define SYSTEM_H

#include "entity_manager.h" // For Entity and Signature definitions.
#include <assert.h>
#include <stdint.h>

#define MAX_SYSTEM_ENTITIES MAX_ENTITIES

typedef struct {
    Entity entities[MAX_SYSTEM_ENTITIES];
    int count;
    Signature requiredSignature;  // Bitmask representing required components.
} ECS_System;

// Add an entity to the system (ensuring no duplicates).
static inline void ECS_System_AddEntity(ECS_System* sys, Entity entity) {
    for (int i = 0; i < sys->count; i++) {
        if (sys->entities[i] == entity) {
            return; // Already present.
        }
    }
    assert(sys->count < MAX_SYSTEM_ENTITIES && "System entity list is full.");
    sys->entities[sys->count++] = entity;
}

// Remove an entity from the system.
static inline void ECS_System_RemoveEntity(ECS_System* sys, Entity entity) {
    int i;
    for (i = 0; i < sys->count; i++) {
        if (sys->entities[i] == entity) {
            break;
        }
    }
    if (i < sys->count) {
        for (; i < sys->count - 1; i++) {
            sys->entities[i] = sys->entities[i + 1];
        }
        sys->count--;
    }
}

#endif // SYSTEM_H

================
File: TransformComponent.h
================
#pragma once

// TransformComponent.h
#ifndef TRANSFORM_COMPONENT_H
#define TRANSFORM_COMPONENT_H

#include "ComponentArray.h"
#include "Components.h"  // This should include the definition of Transform

// Expand the macro to generate the Transform component array.
DEFINE_COMPONENT_ARRAY(Transform)

#endif // TRANSFORM_COMPONENT_H



================================================================
End of Codebase
================================================================
